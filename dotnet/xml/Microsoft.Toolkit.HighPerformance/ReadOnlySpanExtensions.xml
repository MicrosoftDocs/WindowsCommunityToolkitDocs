<Type Name="ReadOnlySpanExtensions" FullName="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions">
  <TypeSignature Language="C#" Value="public static class ReadOnlySpanExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ReadOnlySpanExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions" />
  <TypeSignature Language="VB.NET" Value="Public Module ReadOnlySpanExtensions" />
  <TypeSignature Language="F#" Value="type ReadOnlySpanExtensions = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Helpers for working with the <see cref="T:System.ReadOnlySpan`1" /> type.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsBytes&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;byte&gt; AsBytes&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; AsBytes&lt;struct .ctor (class System.ValueType) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.AsBytes``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsBytes(Of T As Structure) (span As ReadOnlySpan(Of T)) As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="F#" Value="static member AsBytes : ReadOnlySpan&lt;'T (requires 'T : struct)&gt; -&gt; ReadOnlySpan&lt;byte&gt; (requires 'T : struct)" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.AsBytes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type if items in the source <see cref="T:System.ReadOnlySpan`1" />.</typeparam>
        <param name="span">The source slice, of type <typeparamref name="T" />.</param>
        <summary>
            Casts a <see cref="T:System.ReadOnlySpan`1" /> of one primitive type <typeparamref name="T" /> to <see cref="T:System.ReadOnlySpan`1" /> of bytes.
            </summary>
        <returns>A <see cref="T:System.ReadOnlySpan`1" /> of bytes.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
            Thrown if the <see cref="P:System.ReadOnlySpan`1.Length" /> property of the new <see cref="T:System.ReadOnlySpan`1" /> would exceed <see cref="F:System.Int32.MaxValue" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan2D&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D&lt;T&gt; AsSpan2D&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, int height, int width);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D`1&lt;!!T&gt; AsSpan2D&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, int32 height, int32 width) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.AsSpan2D``1(System.ReadOnlySpan{``0},System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan2D(Of T) (span As ReadOnlySpan(Of T), height As Integer, width As Integer) As ReadOnlySpan2D(Of T)" />
      <MemberSignature Language="F#" Value="static member AsSpan2D : ReadOnlySpan&lt;'T&gt; * int * int -&gt; Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D&lt;'T&gt;" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.AsSpan2D (span, height, width)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the input <see cref="T:System.ReadOnlySpan`1" /> instance.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> instance.</param>
        <param name="height">The height of the resulting 2D area.</param>
        <param name="width">The width of each row in the resulting 2D area.</param>
        <summary>
            Returns a <see cref="T:Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D`1" /> instance wrapping the underlying data for the given <see cref="T:System.ReadOnlySpan`1" /> instance.
            </summary>
        <returns>The resulting <see cref="T:Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D`1" /> instance.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when one of the input parameters is out of range.
            </exception>
        <exception cref="T:System.ArgumentException">
            Thrown when the requested area is outside of bounds for <paramref name="span" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan2D&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D&lt;T&gt; AsSpan2D&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, int offset, int height, int width, int pitch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D`1&lt;!!T&gt; AsSpan2D&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, int32 offset, int32 height, int32 width, int32 pitch) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.AsSpan2D``1(System.ReadOnlySpan{``0},System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan2D(Of T) (span As ReadOnlySpan(Of T), offset As Integer, height As Integer, width As Integer, pitch As Integer) As ReadOnlySpan2D(Of T)" />
      <MemberSignature Language="F#" Value="static member AsSpan2D : ReadOnlySpan&lt;'T&gt; * int * int * int * int -&gt; Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D&lt;'T&gt;" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.AsSpan2D (span, offset, height, width, pitch)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="pitch" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the input <see cref="T:System.ReadOnlySpan`1" /> instance.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> instance.</param>
        <param name="offset">The initial offset within <paramref name="span" />.</param>
        <param name="height">The height of the resulting 2D area.</param>
        <param name="width">The width of each row in the resulting 2D area.</param>
        <param name="pitch">The pitch in the resulting 2D area.</param>
        <summary>
            Returns a <see cref="T:Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D`1" /> instance wrapping the underlying data for the given <see cref="T:System.ReadOnlySpan`1" /> instance.
            </summary>
        <returns>The resulting <see cref="T:Microsoft.Toolkit.HighPerformance.ReadOnlySpan2D`1" /> instance.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when one of the input parameters is out of range.
            </exception>
        <exception cref="T:System.ArgumentException">
            Thrown when the requested area is outside of bounds for <paramref name="span" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;TTo&gt; Cast&lt;TFrom,TTo&gt; (this ReadOnlySpan&lt;TFrom&gt; span) where TFrom : struct where TTo : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!TTo&gt; Cast&lt;struct .ctor (class System.ValueType) TFrom, struct .ctor (class System.ValueType) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.Cast``2(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TFrom As Structure, TTo As Structure) (span As ReadOnlySpan(Of TFrom)) As ReadOnlySpan(Of TTo)" />
      <MemberSignature Language="F#" Value="static member Cast : ReadOnlySpan&lt;'From (requires 'From : struct)&gt; -&gt; ReadOnlySpan&lt;'o (requires 'o : struct)&gt; (requires 'From : struct and 'o : struct)" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.Cast span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;TFrom&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom">The type of items in the source <see cref="T:System.ReadOnlySpan`1" />.</typeparam>
        <typeparam name="TTo">The type of items in the destination <see cref="T:System.ReadOnlySpan`1" />.</typeparam>
        <param name="span">The source slice, of type <typeparamref name="TFrom" />.</param>
        <summary>
            Casts a <see cref="T:System.ReadOnlySpan`1" /> of one primitive type <typeparamref name="TFrom" /> to another primitive type <typeparamref name="TTo" />.
            </summary>
        <returns>A <see cref="T:System.ReadOnlySpan`1" /> of type <typeparamref name="TTo" /></returns>
        <remarks>
            Supported only for platforms that support misaligned memory access or when the memory block is aligned by other means.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.CopyTo``1(System.ReadOnlySpan{``0},Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo(Of T) (span As ReadOnlySpan(Of T), destination As RefEnumerable(Of T))" />
      <MemberSignature Language="F#" Value="static member CopyTo : ReadOnlySpan&lt;'T&gt; * Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable&lt;'T&gt; -&gt; unit" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.CopyTo (span, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="destination" Type="Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the input <see cref="T:System.ReadOnlySpan`1" /> instance.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> instance.</param>
        <param name="destination">The <see cref="T:Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable`1" /> instance to copy items into.</param>
        <summary>
            Copies the contents of a given <see cref="T:System.ReadOnlySpan`1" /> into destination <see cref="T:Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable`1" /> instance.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
            Thrown when the destination <see cref="T:Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable`1" /> is shorter than the source <see cref="T:System.ReadOnlySpan`1" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.Count``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Integer" />
      <MemberSignature Language="F#" Value="static member Count : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.Count (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the input <see cref="T:System.ReadOnlySpan`1" /> instance.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> instance to read.</param>
        <param name="value">The <typeparamref name="T" /> value to look for.</param>
        <summary>
            Counts the number of occurrences of a given value into a target <see cref="T:System.ReadOnlySpan`1" /> instance.
            </summary>
        <returns>The number of occurrences of <paramref name="value" /> in <paramref name="span" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetLookupReferenceAt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly T DangerousGetLookupReferenceAt&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, int i);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T DangerousGetLookupReferenceAt&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.DangerousGetLookupReferenceAt``1(System.ReadOnlySpan{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DangerousGetLookupReferenceAt(Of T) (span As ReadOnlySpan(Of T), i As Integer) As T" />
      <MemberSignature Language="F#" Value="static member DangerousGetLookupReferenceAt : ReadOnlySpan&lt;'T&gt; * int -&gt; 'T" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.DangerousGetLookupReferenceAt (span, i)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input <see cref="T:System.ReadOnlySpan`1" /> instance.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> instance.</param>
        <param name="i">The index of the element to retrieve within <paramref name="span" />.</param>
        <summary>
             Returns a reference to the first element within a given <see cref="T:System.ReadOnlySpan`1" />, clamping the input index in the valid range.
             If the <paramref name="i" /> parameter exceeds the length of <paramref name="span" />, it will be clamped to 0.
             Therefore, the returned reference will always point to a valid element within <paramref name="span" />, assuming it is not empty.
             This method is specifically meant to efficiently index lookup tables, especially if they point to constant data.
             Consider this example where a lookup table is used to validate whether a given character is within a specific set:
             <code>
             public static ReadOnlySpan&lt;bool&gt; ValidSetLookupTable =&gt; new bool[]
             {
                 false, true, true, true, true, true, false, true,
                 false, false, true, false, true, false, true, false,
                 true, false, false, true, false, false, false, false,
                 false, false, false, false, true, true, false, true
             };
            
             int ch = Console.Read();
             bool isValid = ValidSetLookupTable.DangerousGetLookupReference(ch);
             </code>
             Even if the input index is outside the range of the lookup table, being clamped to 0, it will
             just cause the value 0 to be returned in this case, which is functionally the same for the check
             being performed. This extension can easily be used whenever the first position in a lookup
             table being referenced corresponds to a falsey value, like in this case.
             Additionally, the example above leverages a compiler optimization introduced with C# 7.3,
             which allows <see cref="T:System.ReadOnlySpan`1" /> instances pointing to compile-time constant data
             to be directly mapped to the static .text section in the final assembly: the array being
             created in code will never actually be allocated, and the <see cref="T:System.ReadOnlySpan`1" /> will
             just point to constant data. Note that this only works for blittable values that are not
             dependent on the byte endianness of the system, like <see cref="T:System.Byte" /> or <see cref="T:System.Boolean" />.
             For more info, see <see href="https://vcsjones.dev/2019/02/01/csharp-readonly-span-bytes-static/" />.
             </summary>
        <returns>
             A reference to the element within <paramref name="span" /> at the index specified by <paramref name="i" />,
             or a reference to the first element within <paramref name="span" /> if <paramref name="i" /> was not a valid index.
             </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetReference&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T DangerousGetReference&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T DangerousGetReference&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.DangerousGetReference``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DangerousGetReference(Of T) (span As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member DangerousGetReference : ReadOnlySpan&lt;'T&gt; -&gt; 'T" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.DangerousGetReference span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input <see cref="T:System.ReadOnlySpan`1" /> instance.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> instance.</param>
        <summary>
            Returns a reference to the first element within a given <see cref="T:System.ReadOnlySpan`1" />, with no bounds checks.
            </summary>
        <returns>A reference to the first element within <paramref name="span" />.</returns>
        <remarks>This method doesn't do any bounds checks, therefore it is responsibility of the caller to perform checks in case the returned value is dereferenced.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetReferenceAt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T DangerousGetReferenceAt&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, int i);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T DangerousGetReferenceAt&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.DangerousGetReferenceAt``1(System.ReadOnlySpan{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DangerousGetReferenceAt(Of T) (span As ReadOnlySpan(Of T), i As Integer) As T" />
      <MemberSignature Language="F#" Value="static member DangerousGetReferenceAt : ReadOnlySpan&lt;'T&gt; * int -&gt; 'T" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.DangerousGetReferenceAt (span, i)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input <see cref="T:System.ReadOnlySpan`1" /> instance.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> instance.</param>
        <param name="i">The index of the element to retrieve within <paramref name="span" />.</param>
        <summary>
            Returns a reference to an element at a specified index within a given <see cref="T:System.ReadOnlySpan`1" />, with no bounds checks.
            </summary>
        <returns>A reference to the element within <paramref name="span" /> at the index specified by <paramref name="i" />.</returns>
        <remarks>This method doesn't do any bounds checks, therefore it is responsibility of the caller to ensure the <paramref name="i" /> parameter is valid.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetReferenceAt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T DangerousGetReferenceAt&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, IntPtr i);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T DangerousGetReferenceAt&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, native int i) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.DangerousGetReferenceAt``1(System.ReadOnlySpan{``0},System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DangerousGetReferenceAt(Of T) (span As ReadOnlySpan(Of T), i As IntPtr) As T" />
      <MemberSignature Language="F#" Value="static member DangerousGetReferenceAt : ReadOnlySpan&lt;'T&gt; * nativeint -&gt; 'T" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.DangerousGetReferenceAt (span, i)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="i" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input <see cref="T:System.ReadOnlySpan`1" /> instance.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> instance.</param>
        <param name="i">The index of the element to retrieve within <paramref name="span" />.</param>
        <summary>
            Returns a reference to an element at a specified index within a given <see cref="T:System.ReadOnlySpan`1" />, with no bounds checks.
            </summary>
        <returns>A reference to the element within <paramref name="span" /> at the index specified by <paramref name="i" />.</returns>
        <remarks>This method doesn't do any bounds checks, therefore it is responsibility of the caller to ensure the <paramref name="i" /> parameter is valid.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Enumerate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanEnumerable&lt;T&gt; Enumerate&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanEnumerable`1&lt;!!T&gt; Enumerate&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.Enumerate``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Enumerate(Of T) (span As ReadOnlySpan(Of T)) As ReadOnlySpanEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="static member Enumerate : ReadOnlySpan&lt;'T&gt; -&gt; Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanEnumerable&lt;'T&gt;" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.Enumerate span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items to enumerate.</typeparam>
        <param name="span">The source <see cref="T:System.ReadOnlySpan`1" /> to enumerate.</param>
        <summary>
             Enumerates the items in the input <see cref="T:System.ReadOnlySpan`1" /> instance, as pairs of value/index values.
             This extension should be used directly within a <see langword="foreach" /> loop:
             <code>
             ReadOnlySpan&lt;string&gt; words = new[] { "Hello", ", ", "world", "!" };
            
             foreach (var item in words.Enumerate())
             {
                 // Access the index and value of each item here...
                 int index = item.Index;
                 string value = item.Value;
             }
             </code>
             The compiler will take care of properly setting up the <see langword="foreach" /> loop with the type returned from this method.
             </summary>
        <returns>A wrapper type that will handle the value/index enumeration for <paramref name="span" />.</returns>
        <remarks>The returned <see cref="T:Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanEnumerable`1" /> value shouldn't be used directly: use this extension in a <see langword="foreach" /> loop.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDjb2HashCode&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int GetDjb2HashCode&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDjb2HashCode&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.GetDjb2HashCode``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetDjb2HashCode(Of T) (span As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member GetDjb2HashCode : ReadOnlySpan&lt;'T&gt; -&gt; int" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.GetDjb2HashCode span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the input <see cref="T:System.ReadOnlySpan`1" /> instance.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> instance.</param>
        <summary>
            Gets a content hash from the input <see cref="T:System.ReadOnlySpan`1" /> instance using the Djb2 algorithm.
            It was designed by <see href="https://en.wikipedia.org/wiki/Daniel_J._Bernstein">Daniel J. Bernstein</see> and is a
            <see href="https://en.wikipedia.org/wiki/List_of_hash_functions#Non-cryptographic_hash_functions">non-cryptographic has function</see>.
            The main advantages of this algorithm are a good distribution of the resulting hash codes, which results in a relatively low
            number of collisions, while at the same time being particularly fast to process, making it suitable for quickly hashing
            even long sequences of values. For the reference implementation, see: <see href="http://www.cse.yorku.ca/~oz/hash.html" />.
            For details on the used constants, see the details provided in this StackOverflow answer (as well as the accepted one):
            <see href="https://stackoverflow.com/questions/10696223/reason-for-5381-number-in-djb-hash-function/13809282#13809282" />.
            Additionally, a comparison between some common hashing algorithms can be found in the reply to this StackExchange question:
            <see href="https://softwareengineering.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed" />.
            Note that the exact implementation is slightly different in this method when it is not called on a sequence of <see cref="T:System.Byte" />
            values: in this case the <see cref="M:System.Object.GetHashCode" /> method will be invoked for each <typeparamref name="T" /> value in
            the provided <see cref="T:System.ReadOnlySpan`1" /> instance, and then those values will be combined using the Djb2 algorithm.
            </summary>
        <returns>The Djb2 value for the input <see cref="T:System.ReadOnlySpan`1" /> instance.</returns>
        <remarks>The Djb2 hash is fully deterministic and with no random components.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ref T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, [in]!!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T) (span As ReadOnlySpan(Of T), ByRef value As T) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;'T&gt; * 'T -&gt; int" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The type if items in the input <see cref="T:System.ReadOnlySpan`1" />.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> to calculate the index for.</param>
        <param name="value">The reference to the target item to get the index for.</param>
        <summary>
            Gets the index of an element of a given <see cref="T:System.ReadOnlySpan`1" /> from its reference.
            </summary>
        <returns>The index of <paramref name="value" /> within <paramref name="span" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="value" /> does not belong to <paramref name="span" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Tokenize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanTokenizer&lt;T&gt; Tokenize&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T separator) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanTokenizer`1&lt;!!T&gt; Tokenize&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.Tokenize``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Tokenize(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), separator As T) As ReadOnlySpanTokenizer(Of T)" />
      <MemberSignature Language="F#" Value="static member Tokenize : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanTokenizer&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.Tokenize (span, separator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanTokenizer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="separator" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the <see cref="T:System.ReadOnlySpan`1" /> to tokenize.</typeparam>
        <param name="span">The source <see cref="T:System.ReadOnlySpan`1" /> to tokenize.</param>
        <param name="separator">The separator <typeparamref name="T" /> item to use.</param>
        <summary>
             Tokenizes the values in the input <see cref="T:System.ReadOnlySpan`1" /> instance using a specified separator.
             This extension should be used directly within a <see langword="foreach" /> loop:
             <code>
             ReadOnlySpan&lt;char&gt; text = "Hello, world!";
            
             foreach (var token in text.Tokenize(','))
             {
                 // Access the tokens here...
             }
             </code>
             The compiler will take care of properly setting up the <see langword="foreach" /> loop with the type returned from this method.
             </summary>
        <returns>A wrapper type that will handle the tokenization for <paramref name="span" />.</returns>
        <remarks>The returned <see cref="T:Microsoft.Toolkit.HighPerformance.Enumerables.ReadOnlySpanTokenizer`1" /> value shouldn't be used directly: use this extension in a <see langword="foreach" /> loop.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryCopyTo&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCopyTo&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.TryCopyTo``1(System.ReadOnlySpan{``0},Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryCopyTo(Of T) (span As ReadOnlySpan(Of T), destination As RefEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryCopyTo : ReadOnlySpan&lt;'T&gt; * Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable&lt;'T&gt; -&gt; bool" Usage="Microsoft.Toolkit.HighPerformance.ReadOnlySpanExtensions.TryCopyTo (span, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="destination" Type="Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the input <see cref="T:System.ReadOnlySpan`1" /> instance.</typeparam>
        <param name="span">The input <see cref="T:System.ReadOnlySpan`1" /> instance.</param>
        <param name="destination">The <see cref="T:Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable`1" /> instance to copy items into.</param>
        <summary>
            Attempts to copy the contents of a given <see cref="T:System.ReadOnlySpan`1" /> into destination <see cref="T:Microsoft.Toolkit.HighPerformance.Enumerables.RefEnumerable`1" /> instance.
            </summary>
        <returns>Whether or not the operation was successful.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
