<Type Name="ArrayExtensions" FullName="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions">
  <TypeSignature Language="C#" Value="public static class ArrayExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ArrayExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions" />
  <TypeSignature Language="VB.NET" Value="Public Module ArrayExtensions" />
  <TypeSignature Language="F#" Value="type ArrayExtensions = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
    <AssemblyVersion>6.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Helpers for working with the <see cref="T:System.Array" /> type.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Count&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;T&gt; (this T[,] array, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(!!T[,] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.Count``1(``0[0:,0:],``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of T As IEquatable(Of T)) (array As T(,), value As T) As Integer" />
      <MemberSignature Language="F#" Value="static member Count : 'T[,] * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.Count (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[,]" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the input 2D <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input 2D <typeparamref name="T" /> array instance.</param>
        <param name="value">The <typeparamref name="T" /> value to look for.</param>
        <summary>
            Counts the number of occurrences of a given value into a target 2D <typeparamref name="T" /> array instance.
            </summary>
        <returns>The number of occurrences of <paramref name="value" /> in <paramref name="array" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;T&gt; (this T[] array, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.Count``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of T As IEquatable(Of T)) (array As T(), value As T) As Integer" />
      <MemberSignature Language="F#" Value="static member Count : 'T[] * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.Count (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the input <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input <typeparamref name="T" /> array instance.</param>
        <param name="value">The <typeparamref name="T" /> value to look for.</param>
        <summary>
            Counts the number of occurrences of a given value into a target <typeparamref name="T" /> array instance.
            </summary>
        <returns>The number of occurrences of <paramref name="value" /> in <paramref name="array" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetReference&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T DangerousGetReference&lt;T&gt; (this T[,] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T DangerousGetReference&lt;T&gt;(!!T[,] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.DangerousGetReference``1(``0[0:,0:])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DangerousGetReference(Of T) (array As T(,)) As T" />
      <MemberSignature Language="F#" Value="static member DangerousGetReference : 'T[,] -&gt; 'T" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.DangerousGetReference array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[,]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input 2D <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input <typeparamref name="T" /> array instance.</param>
        <summary>
            Returns a reference to the first element within a given 2D <typeparamref name="T" /> array, with no bounds checks.
            </summary>
        <returns>A reference to the first element within <paramref name="array" />, or the location it would have used, if <paramref name="array" /> is empty.</returns>
        <remarks>This method doesn't do any bounds checks, therefore it is responsibility of the caller to perform checks in case the returned value is dereferenced.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetReference&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T DangerousGetReference&lt;T&gt; (this T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T DangerousGetReference&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.DangerousGetReference``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DangerousGetReference(Of T) (array As T()) As T" />
      <MemberSignature Language="F#" Value="static member DangerousGetReference : 'T[] -&gt; 'T" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.DangerousGetReference array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input <typeparamref name="T" /> array instance.</param>
        <summary>
            Returns a reference to the first element within a given <typeparamref name="T" /> array, with no bounds checks.
            </summary>
        <returns>A reference to the first element within <paramref name="array" />, or the location it would have used, if <paramref name="array" /> is empty.</returns>
        <remarks>This method doesn't do any bounds checks, therefore it is responsibility of the caller to perform checks in case the returned value is dereferenced.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetReferenceAt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T DangerousGetReferenceAt&lt;T&gt; (this T[] array, int i);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T DangerousGetReferenceAt&lt;T&gt;(!!T[] array, int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.DangerousGetReferenceAt``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DangerousGetReferenceAt(Of T) (array As T(), i As Integer) As T" />
      <MemberSignature Language="F#" Value="static member DangerousGetReferenceAt : 'T[] * int -&gt; 'T" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.DangerousGetReferenceAt (array, i)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input <typeparamref name="T" /> array instance.</param>
        <param name="i">The index of the element to retrieve within <paramref name="array" />.</param>
        <summary>
            Returns a reference to an element at a specified index within a given <typeparamref name="T" /> array, with no bounds checks.
            </summary>
        <returns>A reference to the element within <paramref name="array" /> at the index specified by <paramref name="i" />.</returns>
        <remarks>This method doesn't do any bounds checks, therefore it is responsibility of the caller to ensure the <paramref name="i" /> parameter is valid.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetReferenceAt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T DangerousGetReferenceAt&lt;T&gt; (this T[,] array, int i, int j);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T DangerousGetReferenceAt&lt;T&gt;(!!T[,] array, int32 i, int32 j) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.DangerousGetReferenceAt``1(``0[0:,0:],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DangerousGetReferenceAt(Of T) (array As T(,), i As Integer, j As Integer) As T" />
      <MemberSignature Language="F#" Value="static member DangerousGetReferenceAt : 'T[,] * int * int -&gt; 'T" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.DangerousGetReferenceAt (array, i, j)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[,]" RefType="this" />
        <Parameter Name="i" Type="System.Int32" />
        <Parameter Name="j" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input 2D <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input 2D <typeparamref name="T" /> array instance.</param>
        <param name="i">The vertical index of the element to retrieve within <paramref name="array" />.</param>
        <param name="j">The horizontal index of the element to retrieve within <paramref name="array" />.</param>
        <summary>
            Returns a reference to an element at a specified coordinate within a given 2D <typeparamref name="T" /> array, with no bounds checks.
            </summary>
        <returns>A reference to the element within <paramref name="array" /> at the coordinate specified by <paramref name="i" /> and <paramref name="j" />.</returns>
        <remarks>
            This method doesn't do any bounds checks, therefore it is responsibility of the caller to ensure the <paramref name="i" />
            and <paramref name="j" /> parameters are valid. Furthermore, this extension will ignore the lower bounds for the input
            array, and will just assume that the input index is 0-based. It is responsability of the caller to adjust the input
            indices to account for the actual lower bounds, if the input array has either axis not starting at 0.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enumerate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.Toolkit.HighPerformance.Enumerables.SpanEnumerable&lt;T&gt; Enumerate&lt;T&gt; (this T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.Toolkit.HighPerformance.Enumerables.SpanEnumerable`1&lt;!!T&gt; Enumerate&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.Enumerate``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Enumerate(Of T) (array As T()) As SpanEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="static member Enumerate : 'T[] -&gt; Microsoft.Toolkit.HighPerformance.Enumerables.SpanEnumerable&lt;'T&gt;" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.Enumerate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Toolkit.HighPerformance.Enumerables.SpanEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items to enumerate.</typeparam>
        <param name="array">The source <typeparamref name="T" /> array to enumerate.</param>
        <summary>
             Enumerates the items in the input <typeparamref name="T" /> array instance, as pairs of reference/index values.
             This extension should be used directly within a <see langword="foreach" /> loop:
             <code>
             int[] numbers = new[] { 1, 2, 3, 4, 5, 6, 7 };
            
             foreach (var item in numbers.Enumerate())
             {
                 // Access the index and value of each item here...
                 int index = item.Index;
                 ref int value = ref item.Value;
             }
             </code>
             The compiler will take care of properly setting up the <see langword="foreach" /> loop with the type returned from this method.
             </summary>
        <returns>A wrapper type that will handle the reference/index enumeration for <paramref name="array" />.</returns>
        <remarks>The returned <see cref="T:Microsoft.Toolkit.HighPerformance.Enumerables.SpanEnumerable`1" /> value shouldn't be used directly: use this extension in a <see langword="foreach" /> loop.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (this T[,] array, T value, int row, int column, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[,] array, !!T value, int32 row, int32 column, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.Fill``1(``0[0:,0:],``0,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Fill(Of T) (array As T(,), value As T, row As Integer, column As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[,] * 'T * int * int * int * int -&gt; unit" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.Fill (array, value, row, column, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[,]" RefType="this" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="row" Type="System.Int32" />
        <Parameter Name="column" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input 2D <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input <typeparamref name="T" /> array instance.</param>
        <param name="value">The <typeparamref name="T" /> value to fill the target area with.</param>
        <param name="row">The row to start on (inclusive, 0-based index).</param>
        <param name="column">The column to start on (inclusive, 0-based index).</param>
        <param name="width">The positive width of area to fill.</param>
        <param name="height">The positive height of area to fill.</param>
        <summary>
            Fills an area in a given 2D <typeparamref name="T" /> array instance with a specified value.
            This API will try to fill as many items as possible, ignoring positions outside the bounds of the array.
            If invalid coordinates are given, they will simply be ignored and no exception will be thrown.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetColumn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.Toolkit.HighPerformance.Enumerables.Array2DColumnEnumerable&lt;T&gt; GetColumn&lt;T&gt; (this T[,] array, int column);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.Toolkit.HighPerformance.Enumerables.Array2DColumnEnumerable`1&lt;!!T&gt; GetColumn&lt;T&gt;(!!T[,] array, int32 column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.GetColumn``1(``0[0:,0:],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetColumn(Of T) (array As T(,), column As Integer) As Array2DColumnEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="static member GetColumn : 'T[,] * int -&gt; Microsoft.Toolkit.HighPerformance.Enumerables.Array2DColumnEnumerable&lt;'T&gt;" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.GetColumn (array, column)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Toolkit.HighPerformance.Enumerables.Array2DColumnEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[,]" RefType="this" />
        <Parameter Name="column" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input 2D <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input <typeparamref name="T" /> array instance.</param>
        <param name="column">The target column to retrieve (0-based index).</param>
        <summary>
             Returns an enumerable that returns the items from a given column in a given 2D <typeparamref name="T" /> array instance.
             This extension should be used directly within a <see langword="foreach" /> loop:
             <code>
             int[,] matrix =
             {
                 { 1, 2, 3 },
                 { 4, 5, 6 },
                 { 7, 8, 9 }
             };
            
             foreach (ref int number in matrix.GetColumn(1))
             {
                 // Access the current number by reference here...
             }
             </code>
             The compiler will take care of properly setting up the <see langword="foreach" /> loop with the type returned from this method.
             </summary>
        <returns>A wrapper type that will handle the column enumeration for <paramref name="array" />.</returns>
        <remarks>The returned <see cref="T:Microsoft.Toolkit.HighPerformance.Enumerables.Array2DColumnEnumerable`1" /> value shouldn't be used directly: use this extension in a <see langword="foreach" /> loop.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDjb2HashCode&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int GetDjb2HashCode&lt;T&gt; (this T[,] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDjb2HashCode&lt;T&gt;(!!T[,] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.GetDjb2HashCode``1(``0[0:,0:])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetDjb2HashCode(Of T) (array As T(,)) As Integer" />
      <MemberSignature Language="F#" Value="static member GetDjb2HashCode : 'T[,] -&gt; int" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.GetDjb2HashCode array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[,]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the input 2D <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input 2D <typeparamref name="T" /> array instance.</param>
        <summary>
            Gets a content hash from the input 2D <typeparamref name="T" /> array instance using the Djb2 algorithm.
            For more info, see the documentation for <see cref="M:Microsoft.Toolkit.HighPerformance.Extensions.ReadOnlySpanExtensions.GetDjb2HashCode``1(System.ReadOnlySpan{``0})" />.
            </summary>
        <returns>The Djb2 value for the input 2D <typeparamref name="T" /> array instance.</returns>
        <remarks>The Djb2 hash is fully deterministic and with no random components.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDjb2HashCode&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int GetDjb2HashCode&lt;T&gt; (this T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDjb2HashCode&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.GetDjb2HashCode``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetDjb2HashCode(Of T) (array As T()) As Integer" />
      <MemberSignature Language="F#" Value="static member GetDjb2HashCode : 'T[] -&gt; int" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.GetDjb2HashCode array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the input <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input <typeparamref name="T" /> array instance.</param>
        <summary>
            Gets a content hash from the input <typeparamref name="T" /> array instance using the Djb2 algorithm.
            For more info, see the documentation for <see cref="M:Microsoft.Toolkit.HighPerformance.Extensions.ReadOnlySpanExtensions.GetDjb2HashCode``1(System.ReadOnlySpan{``0})" />.
            </summary>
        <returns>The Djb2 value for the input <typeparamref name="T" /> array instance.</returns>
        <remarks>The Djb2 hash is fully deterministic and with no random components.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.Toolkit.HighPerformance.Enumerables.Array2DRowEnumerable&lt;T&gt; GetRow&lt;T&gt; (this T[,] array, int row);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.Toolkit.HighPerformance.Enumerables.Array2DRowEnumerable`1&lt;!!T&gt; GetRow&lt;T&gt;(!!T[,] array, int32 row) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.GetRow``1(``0[0:,0:],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetRow(Of T) (array As T(,), row As Integer) As Array2DRowEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="static member GetRow : 'T[,] * int -&gt; Microsoft.Toolkit.HighPerformance.Enumerables.Array2DRowEnumerable&lt;'T&gt;" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.GetRow (array, row)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Toolkit.HighPerformance.Enumerables.Array2DRowEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[,]" RefType="this" />
        <Parameter Name="row" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of elements in the input 2D <typeparamref name="T" /> array instance.</typeparam>
        <param name="array">The input <typeparamref name="T" /> array instance.</param>
        <param name="row">The target row to retrieve (0-based index).</param>
        <summary>
            Returns a <see cref="T:System.Span`1" /> over a row in a given 2D <typeparamref name="T" /> array instance.
            </summary>
        <returns>A <see cref="T:System.Span`1" /> with the items from the target row within <paramref name="array" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tokenize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.Toolkit.HighPerformance.Enumerables.SpanTokenizer&lt;T&gt; Tokenize&lt;T&gt; (this T[] array, T separator) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.Toolkit.HighPerformance.Enumerables.SpanTokenizer`1&lt;!!T&gt; Tokenize&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(!!T[] array, !!T separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.Tokenize``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Tokenize(Of T As IEquatable(Of T)) (array As T(), separator As T) As SpanTokenizer(Of T)" />
      <MemberSignature Language="F#" Value="static member Tokenize : 'T[] * 'T -&gt; Microsoft.Toolkit.HighPerformance.Enumerables.SpanTokenizer&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="Microsoft.Toolkit.HighPerformance.Extensions.ArrayExtensions.Tokenize (array, separator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Toolkit.HighPerformance</AssemblyName>
        <AssemblyVersion>6.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Toolkit.HighPerformance.Enumerables.SpanTokenizer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="separator" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of items in the <typeparamref name="T" /> array to tokenize.</typeparam>
        <param name="array">The source <typeparamref name="T" /> array to tokenize.</param>
        <param name="separator">The separator <typeparamref name="T" /> item to use.</param>
        <summary>
             Tokenizes the values in the input <typeparamref name="T" /> array instance using a specified separator.
             This extension should be used directly within a <see langword="foreach" /> loop:
             <code>
             char[] text = "Hello, world!".ToCharArray();
            
             foreach (var token in text.Tokenize(','))
             {
                 // Access the tokens here...
             }
             </code>
             The compiler will take care of properly setting up the <see langword="foreach" /> loop with the type returned from this method.
             </summary>
        <returns>A wrapper type that will handle the tokenization for <paramref name="array" />.</returns>
        <remarks>The returned <see cref="T:Microsoft.Toolkit.HighPerformance.Enumerables.SpanTokenizer`1" /> value shouldn't be used directly: use this extension in a <see langword="foreach" /> loop.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
